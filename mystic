local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "Mystic Hub",
    Icon = "door-open",
    Author = "by .ftgs and .ftgs",
})

Window:EditOpenButton({
    Title = "Open UI",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})


local Tab = Window:Tab({Title = "Combat", Icon = "crosshair"})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

if not LocalPlayer.Character then
    LocalPlayer.CharacterAdded:Wait()
end
local MyHead = LocalPlayer.Character:WaitForChild("Head")


local FOVRadius = 150
local FOVEnabled = false
local FOVLines = {}
local sides = 20

for i = 1, sides do
    local line = Drawing.new("Line")
    line.Color = Color3.fromRGB(255,255,255)
    line.Thickness = 2
    line.Visible = FOVEnabled
    table.insert(FOVLines, line)
end

local targetLine = Drawing.new("Line")
targetLine.Color = Color3.fromRGB(255,0,0)
targetLine.Thickness = 2
targetLine.Visible = FOVEnabled

Tab:Toggle({
    Title = "Show FOV",
    Default = false,
    Callback = function(state)
        FOVEnabled = state
        for _, line in pairs(FOVLines) do
            line.Visible = state
        end
        targetLine.Visible = state
    end
})

local slider = Tab:Slider({
    Title = "FOV Size",
    Step = 1,
    Value = {Min = 50, Max = 1000, Default = FOVRadius},
    Callback = function(value)
        FOVRadius = tonumber(value) or 150
    end
})
slider.Callback(FOVRadius)


local SilentAimEnabled = true
local CurrentTarget
local head, aimPos

local GunNames = {
    "P226","MP5","M24","Draco","Glock","Sawnoff","Uzi","G3","C9",
    "Hunting Rifle","Anaconda","AK47","Remington","Double Barrel"
}
local GunLookup = {}
for _, name in pairs(GunNames) do
    GunLookup[name] = true
end

local function GetClosestTargetInFOV()
    local closest
    local shortest = math.huge
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local screenPos, onScreen = Camera:WorldToViewportPoint(player.Character.Head.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                if dist <= FOVRadius and dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

local function IsHoldingAllowedGun(args)
    local ok, weapon = pcall(function() return args[3] end)
    if not ok then return false end
    if typeof(weapon) == "Instance" and GunLookup[weapon.Name] then
        return true
    end
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if (child:IsA("Tool") or child:IsA("Model")) and GunLookup[child.Name] then
            return true
        end
    end
    return false
end

local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer, function(self, ...)
    local args = {...}
    if SilentAimEnabled and IsHoldingAllowedGun(args) then
        CurrentTarget = GetClosestTargetInFOV()
        if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
            head = CurrentTarget.Character.Head
            aimPos = head.Position
            args[4] = CFrame.new(1/0,1/0,1/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0,0/0)
            args[5] = {[1]={[1]={["Instance"]=head,["Position"]=aimPos}}}
        end
    end
    return oldFire(self, unpack(args))
end)

RunService.RenderStepped:Connect(function()
    if not FOVEnabled then return end
    local center = Camera.ViewportSize / 2
    local points = {}
    for i = 0, sides-1 do
        local angle = math.rad(i * (360 / sides))
        local x = center.X + FOVRadius * math.cos(angle)
        local y = center.Y + FOVRadius * math.sin(angle)
        table.insert(points, Vector2.new(x,y))
    end
    for i = 1, sides do
        local nextIndex = i % sides + 1
        FOVLines[i].From = points[i]
        FOVLines[i].To = points[nextIndex]
    end

    local target = GetClosestTargetInFOV()
    if target and target.Character and target.Character:FindFirstChild("Head") then
        local targetHead = target.Character.Head
        local myScreen = Camera:WorldToViewportPoint(MyHead.Position)
        local targetScreen = Camera:WorldToViewportPoint(targetHead.Position)
        targetLine.From = Vector2.new(myScreen.X, myScreen.Y)
        targetLine.To = Vector2.new(targetScreen.X, targetScreen.Y)
        targetLine.Visible = true
    else
        targetLine.Visible = false
    end
end)

local TabESP = Window:Tab({Title = "ESP", Icon = "eye"})


local ESPNameEnabled = false
local ESPTraceEnabled = false
local ItemESPEnabled = false


TabESP:Toggle({
    Title = "ESP Name",
    Default = false,
    Callback = function(state)
        ESPNameEnabled = state
        for _, gui in ipairs(LocalPlayer.PlayerGui:GetChildren()) do
            if gui.Name:match("^ESP_") then
                gui.Enabled = state
            end
        end
    end
})


TabESP:Toggle({
    Title = "ESP Trace",
    Default = false,
    Callback = function(state)
        ESPTraceEnabled = state
        for _, line in pairs(Traces) do
            line.Visible = state
        end
    end
})


TabESP:Toggle({
    Title = "Item ESP",
    Default = false,
    Callback = function(state)
        ItemESPEnabled = state
        for _, billboard in pairs(BillboardCache) do
            if billboard and billboard.Parent then
                billboard.Enabled = state
            end
        end
    end
})


local function createESP(player)
    if player == LocalPlayer then return end

    local function addBillboard(character)
        local head = character:WaitForChild("Head", 5)
        if not head then return end

        local old = LocalPlayer.PlayerGui:FindFirstChild("ESP_" .. player.Name)
        if old then old:Destroy() end

        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP_" .. player.Name
        billboard.Adornee = head
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 100, 0, 20)
        billboard.StudsOffset = Vector3.new(0, 1.5, 0)
        billboard.Enabled = ESPNameEnabled
        billboard.Parent = LocalPlayer:WaitForChild("PlayerGui")

        local text = Instance.new("TextLabel")
        text.Size = UDim2.new(1, 0, 1, 0)
        text.BackgroundTransparency = 1
        text.Text = player.Name
        text.TextColor3 = Color3.fromRGB(255, 255, 255)
        text.TextSize = 9
        text.Font = Enum.Font.Gotham
        text.TextStrokeTransparency = 0.9
        text.Parent = billboard

        player.CharacterRemoving:Connect(function()
            if billboard then billboard:Destroy() end
        end)
    end

    if player.Character then addBillboard(player.Character) end
    player.CharacterAdded:Connect(addBillboard)
end

for _, player in ipairs(Players:GetPlayers()) do
    createESP(player)
end
Players.PlayerAdded:Connect(createESP)


local Traces = {}

local function createTrace(player)
    if player == LocalPlayer then return end
    local line = Drawing.new("Line")
    line.Color = Color3.fromRGB(0, 170, 255)
    line.Thickness = 2
    line.Visible = ESPTraceEnabled
    Traces[player] = line
end

for _, player in pairs(Players:GetPlayers()) do
    createTrace(player)
end

Players.PlayerAdded:Connect(createTrace)

Players.PlayerRemoving:Connect(function(player)
    if Traces[player] then
        Traces[player]:Remove()
        Traces[player] = nil
    end
end)

RunService.RenderStepped:Connect(function()
    local screenCenterTop = Vector2.new(Camera.ViewportSize.X/2, 0)
    for player, line in pairs(Traces) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local pos, onScreen = Camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
            if onScreen then
                line.From = screenCenterTop
                line.To = Vector2.new(pos.X, pos.Y)
                line.Visible = ESPTraceEnabled
            else
                line.Visible = false
            end
        else
            line.Visible = false
        end
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local LocalPlayer = Players.LocalPlayer
local ItemESP_Enabled = true
local BillboardCache = {}
local ItemESP_UpdateConnections = {}
local WeaponDB = {}
local PreloadedImages = {}

local RARITY_COLORS = {
    ["Common"] = Color3.fromRGB(255, 255, 255),
    ["Uncommon"] = Color3.fromRGB(99, 255, 52),
    ["Rare"] = Color3.fromRGB(51, 170, 255),
    ["Epic"] = Color3.fromRGB(237, 44, 255),
    ["Legendary"] = Color3.fromRGB(255, 150, 0),
    ["Omega"] = Color3.fromRGB(255, 20, 51),
}

local function generateUniqueKey(tool)
    if not tool or not tool:IsA("Tool") then return nil end

    local itemId = tool:GetAttribute("ItemId") or tool:GetAttribute("Id")
    if itemId and itemId ~= "" and (typeof(itemId) == "string" or typeof(itemId) == "number") then
        return "ITEMID_" .. tostring(itemId)
    end

    local partsData = {}
    for _, part in ipairs(tool:GetDescendants()) do
        if part:IsA("SpecialMesh") and part.MeshId and part.MeshId ~= "" and part.MeshId ~= "rbxassetid://" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureId or "NOTEX"))
        elseif part:IsA("MeshPart") and part.MeshId and part.MeshId ~= "" and part.MeshId ~= "rbxassetid://" then
            table.insert(partsData, "MESH_"..part.MeshId.."|TEX_"..(part.TextureID or "NOTEX"))
        elseif part:IsA("Decal") and part.Texture and part.Texture ~= "" and part.Texture ~= "rbxassetid://" then
            table.insert(partsData, "DECAL_"..part.Texture)
        elseif part:IsA("Part") then
            table.insert(partsData, "PART_"..part.Name.."_"..part.Size.X.."x"..part.Size.Y.."x"..part.Size.Z)
        end
    end

    if #partsData > 0 then
        table.sort(partsData)
        return "MESHKEY_" .. table.concat(partsData, ";")
    end

    local displayName = tool:GetAttribute("DisplayName") or tool.Name
    local toolName = tool.Name
    local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Unknown"
    local imageId = tool:GetAttribute("ImageId") or "NOIMAGE"
    return "NAME_" .. displayName .. "_" .. toolName .. "_" .. rarity .. "_" .. imageId
end


local function registerItems(folder)
    for _, tool in ipairs(folder:GetDescendants()) do
        if not tool:IsA("Tool") then continue end
        local key = generateUniqueKey(tool)
        if not key then continue end

        local displayName = tool:GetAttribute("DisplayName") or tool.Name
        local imageId = tool:GetAttribute("ImageId") or "rbxassetid://7072725737"
        local rarity = tool:GetAttribute("RarityName") or tool:GetAttribute("Rarity") or "Common"

        WeaponDB[key] = {
            Name = displayName,
            Rarity = rarity,
            ImageId = imageId,
            ToolName = tool.Name,
            Key = key
        }

        
        if imageId and imageId ~= "" and not PreloadedImages[imageId] then
            PreloadedImages[imageId] = true
            task.spawn(function()
                pcall(function()
                    ContentProvider:PreloadAsync({imageId})
                end)
            end)
        end
    end
end


pcall(function()
    local itemsFolder = ReplicatedStorage:WaitForChild("Items", 5)
    if itemsFolder then registerItems(itemsFolder) end

    for _, obj in ipairs(ReplicatedStorage:GetChildren()) do
        if obj:IsA("Folder") and (obj.Name:find("Weapon") or obj.Name:find("Item") or obj.Name:find("Tool")) then
            registerItems(obj)
        end
    end

    registerItems(game:GetService("StarterPack"))
end)

local function getWeaponInfo(tool)
    if not tool or not tool:IsA("Tool") then return nil end
    local key = generateUniqueKey(tool)
    return WeaponDB[key]
end

local function createBillboardForPlayer(player)
    if player == LocalPlayer or BillboardCache[player] then return end

    local billboard, container, layout
    local connections = {}

    local function updateESP()
        if not ItemESP_Enabled or not billboard.Parent then return end

        local currentTools = {}

        local function scan(folder)
            if not folder then return end
            for _, tool in ipairs(folder:GetChildren()) do
                if tool:IsA("Tool") and tool.Name ~= "Fists" then
                    local info = getWeaponInfo(tool)
                    if info then
                        table.insert(currentTools, info)
                    end
                end
            end
        end

        local char = player.Character
        if char then
            scan(char)
            local backpack = player:FindFirstChild("Backpack")
            if backpack then scan(backpack) end
        end

        container:ClearAllChildren()
        layout = Instance.new("UIGridLayout")
        layout.CellSize = UDim2.new(0, 35, 0, 35)
        layout.CellPadding = UDim2.new(0, 6, 0, 0)
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = container

        for i, info in ipairs(currentTools) do
            local img = Instance.new("ImageLabel")
            img.Parent = container
            img.Size = UDim2.new(0, 35, 0, 35)
            img.BackgroundTransparency = 1
            img.Image = info.ImageId or "rbxassetid://7072725737"
            img.ScaleType = Enum.ScaleType.Fit
            img.LayoutOrder = i

            local color = RARITY_COLORS[info.Rarity] or Color3.fromRGB(255, 255, 255)
            img.ImageColor3 = color:Lerp(Color3.new(1,1,1), 0.35)
        end
    end

    local function setupBillboard()
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if BillboardCache[player] then
            BillboardCache[player]:Destroy()
        end
        for _, conn in pairs(connections) do
            if conn.Connected then conn:Disconnect() end
        end
        connections = {}

        billboard = Instance.new("BillboardGui")
        billboard.Name = "ItemESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 280, 0, 40)
        billboard.StudsOffset = Vector3.new(0, -6.5, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.Parent = hrp

        container = Instance.new("Frame", billboard)
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1

        BillboardCache[player] = billboard

        updateESP()

        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            table.insert(connections, backpack.ChildAdded:Connect(updateESP))
            table.insert(connections, backpack.ChildRemoved:Connect(updateESP))
        end

        table.insert(connections, char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                task.defer(updateESP)
            end
        end))
        table.insert(connections, char.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then
                task.defer(updateESP)
            end
        end))

        table.insert(connections, player.ChildAdded:Connect(function(child)
            if child.Name == "Backpack" then
                task.wait()
                table.insert(connections, child.ChildAdded:Connect(updateESP))
                table.insert(connections, child.ChildRemoved:Connect(updateESP))
                updateESP()
            end
        end))
    end

    if player.Character then
        task.spawn(setupBillboard)
    end

    
    table.insert(connections, player.CharacterAdded:Connect(function()
        task.wait(1)
        setupBillboard()
    end))

    ItemESP_UpdateConnections[player] = connections
end


for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        createBillboardForPlayer(p)
    end
end


Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        createBillboardForPlayer(p)
    end
end)


Players.PlayerRemoving:Connect(function(p)
    if BillboardCache[p] then
        BillboardCache[p]:Destroy()
        BillboardCache[p] = nil
    end
    if ItemESP_UpdateConnections[p] then
        for _, conn in pairs(ItemESP_UpdateConnections[p]) do
            if conn.Connected then conn:Disconnect() end
        end
        ItemESP_UpdateConnections[p] = nil
    end
end)



local AntikillEnabled = false


local TabMenu = Window:Tab({Title = "Menu", Icon = "menu"})

TabMenu:Toggle({
    Title = "Anti kill",
    Default = false,
    Callback = function(state)
        AntikillEnabled = state
        for _, billboard in pairs(BillboardCache) do
            if billboard and billboard.Parent then
                billboard.Enabled = state
            end
        end
    end
})


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local function goUnderground(root)
    local pos = root.Position
    root.CFrame = CFrame.new(pos.X, pos.Y - 30, pos.Z)
end

local function randomMove(root)
    task.spawn(function()
        local baseY = root.Position.Y -- คงระดับความลึกไว้
        root.Anchored = true
        for i = 1, 25 do
            local x = math.random(-10, 10)
            local z = math.random(-10, 10)
            root.CFrame = CFrame.new(root.Position.X + x, baseY, root.Position.Z + z)
            task.wait(0.05)
        end
        root.Anchored = false
    end)
end

local function goUp(root)
    local pos = root.Position
    root.CFrame = CFrame.new(pos.X, pos.Y + 30, pos.Z)
end

local function resetCharacter()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0
    else
        LocalPlayer:LoadCharacter()
    end
end

local function monitorHealth(character)
    local humanoid = character:WaitForChild("Humanoid")
    local root = character:WaitForChild("HumanoidRootPart")
    local isUnderground = false

    RunService.Heartbeat:Connect(function()
        if humanoid.Health <= 15 and not isUnderground then
            isUnderground = true
            humanoid:ChangeState(Enum.HumanoidStateType.Physics)
            goUnderground(root)
            randomMove(root)
        elseif humanoid.Health > 30 and isUnderground then
            isUnderground = false
            goUp(root)
            task.wait(1)
            resetCharacter()
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    monitorHealth(char)
end)

if LocalPlayer.Character then
    monitorHealth(LocalPlayer.Character)
end


getgenv().Infinitestamina = false
TabMenu:Toggle({
    Title = "Stamina Infinity​",
    Default = false,
    Callback = function(state)
        getgenv().Infinitestamina = state
    end
})


local replicated = game:GetService("ReplicatedStorage")
local SprintModule = require(replicated.Modules.Game.Sprint)
local consume_stamina = SprintModule.consume_stamina
local SprintBar = debug.getupvalue(consume_stamina, 2).sprint_bar

local OldConsume = SprintModule.consume_stamina
local OldUpdate = SprintBar.update

hookfunction(SprintModule.consume_stamina, function(...)
    if getgenv().Infinitestamina then
        return
    end
    return OldConsume(...)
end)

hookfunction(SprintBar.update, function(self, ...)
    if getgenv().Infinitestamina then
        return OldUpdate(self, 1)
    end
    return OldUpdate(self, ...)
end)

